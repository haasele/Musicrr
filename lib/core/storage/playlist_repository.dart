import 'dart:convert';
import 'package:drift/drift.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:uuid/uuid.dart';
import 'database.dart';
import 'now_playing_preset_repository.dart';
import '../models/playlist.dart';

final playlistRepositoryProvider = Provider<PlaylistRepository>((ref) {
  final database = ref.read(appDatabaseProvider);
  return PlaylistRepository(database);
});

class PlaylistRepository {
  final AppDatabase _database;
  final _uuid = const Uuid();

  PlaylistRepository(this._database);

  /// Get all user playlists
  Future<List<Playlist>> getAllPlaylists() async {
    final playlists = await _database.select(_database.userPlaylists).get();
    return playlists.map((row) => _rowToPlaylist(row)).toList();
  }

  /// Get a specific playlist by ID
  Future<Playlist?> getPlaylist(String id) async {
    final query = _database.select(_database.userPlaylists)
      ..where((tbl) => tbl.id.equals(id));
    final row = await query.getSingleOrNull();
    return row != null ? _rowToPlaylist(row) : null;
  }

  /// Create a new playlist
  Future<Playlist> createPlaylist({
    required String name,
    String? description,
    List<String> songIds = const [],
    String? coverArtUri,
  }) async {
    final id = _uuid.v4();
    final now = DateTime.now();
    
    final row = UserPlaylistsCompanion.insert(
      id: id,
      name: name,
      description: Value(description),
      songIdsJson: jsonEncode(songIds),
      coverArtUri: Value(coverArtUri),
      createdAt: now,
    );

    await _database.into(_database.userPlaylists).insert(row);
    return Playlist(
      id: id,
      name: name,
      description: description,
      songIds: songIds,
      coverArtUri: coverArtUri,
      trackCount: songIds.length,
      isAutoGenerated: false,
      createdAt: now,
    );
  }

  /// Update an existing playlist
  Future<void> updatePlaylist(Playlist playlist) async {
    final row = UserPlaylistsCompanion(
      id: Value(playlist.id),
      name: Value(playlist.name),
      description: Value(playlist.description),
      songIdsJson: Value(jsonEncode(playlist.songIds)),
      coverArtUri: Value(playlist.coverArtUri),
      lastModified: Value(DateTime.now()),
    );

    await (_database.update(_database.userPlaylists)..where((tbl) => tbl.id.equals(playlist.id)))
        .write(row);
  }

  /// Add songs to a playlist
  Future<void> addSongsToPlaylist(String playlistId, List<String> songIds) async {
    final playlist = await getPlaylist(playlistId);
    if (playlist == null) return;

    final updatedSongIds = List<String>.from(playlist.songIds);
    for (final songId in songIds) {
      if (!updatedSongIds.contains(songId)) {
        updatedSongIds.add(songId);
      }
    }

    final updated = playlist.copyWith(
      songIds: updatedSongIds,
      trackCount: updatedSongIds.length,
    );
    await updatePlaylist(updated);
  }

  /// Remove songs from a playlist
  Future<void> removeSongsFromPlaylist(String playlistId, List<String> songIds) async {
    final playlist = await getPlaylist(playlistId);
    if (playlist == null) return;

    final updatedSongIds = List<String>.from(playlist.songIds)
      ..removeWhere((id) => songIds.contains(id));

    final updated = playlist.copyWith(
      songIds: updatedSongIds,
      trackCount: updatedSongIds.length,
    );
    await updatePlaylist(updated);
  }

  /// Delete a playlist
  Future<void> deletePlaylist(String id) async {
    await (_database.delete(_database.userPlaylists)..where((tbl) => tbl.id.equals(id))).go();
  }

  /// Convert database row to Playlist model
  Playlist _rowToPlaylist(dynamic row) {
    List<String> songIds = [];
    try {
      final decoded = jsonDecode(row.songIdsJson) as List;
      songIds = decoded.map((e) => e.toString()).toList();
    } catch (e) {
      // Handle JSON decode error
    }

    return Playlist(
      id: row.id,
      name: row.name,
      description: row.description,
      songIds: songIds,
      coverArtUri: row.coverArtUri,
      trackCount: songIds.length,
      isAutoGenerated: false,
      createdAt: row.createdAt,
    );
  }
}
